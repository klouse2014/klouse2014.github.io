{"pages":[{"text":"stl学习笔记 参照《Primer C++》系统的学习一遍stl, 把重要的知识点记录下来 顺序容器 标准库定义了三种顺序容器：vector、list、deque(双端队列), 他们的差别在于访问元素的方式以及添加或删除元素的相关操作的代价;还提供了三种容器适配器: stack、queue、priority_queue. 容器的构造函数 C<T> c; 创建一个空容器, 适用所有容器 C<T> c(c2); 创建容器c2的副本, 适用所有容器 C<T> c(b,e); 创建c, 其元素是迭代器b和e标示范围内元素的副本, 适用所有容器 C<T> c(n,t); 用n个值为t的元素创建容器, 其中t必须是容器C的元素类型的值或者可转换为该类型, 仅适用顺序容器 C<T> c(n); 创建有n个值初始化元素的容器c, 仅适用顺序容器 注意： 1. 将一个容器复制给另一个容器时, 类型必须匹配：容器类型和元素类型都必须相同 2. 使用迭代器时, 不要求容器类型相同, 元素类型相互兼容即可实现复制. 迭代器需要标记出要复制的第一个元素和最后一个元素 3. 由于指针就是迭代器, 因此允许指针实现容器初始化. 第二个指向的是停止复制的条件, 其所指向位置的元素未被复制 4. 只提供元素个数时, 元素必须为内置或复合类型, 或者提供了默认构造函数的类型 char * words [] = { ' 111 ',' 222 ',' 333 ' }; list < string > words2 ( words , words + 3 ); 容器内元素的类型约束 元素类型必须支持赋值运算 元素类型对象必须可以复制 因为容易受容器元素类型的约束, 因此可以定义元素是容器类型的容器. 注意中间需加空格 迭代器 常用运算： *iter 返回迭代器指向元素的引用 iter->mem 对iter解引用, 获得指定元素的mem成员. 等效于 (*iter).mem ++iter iter++ 使iter指向下一个元素 --iter iter-- 使iter指向前一个元素 iter1==iter2 iter1!=iter2 比较两个迭代器是否相等. 当指向同一个容器同一个元素或者同一个容器超出末端的下一个元素时相等 vector和deque迭代器额外运算： iter+n iter-n 在迭代器上加(减)整数值n, 产生指向容器中前面(后面)第n个元素的迭代器. 新计算出来的迭代器必须指向容器中的元素或超出容器末尾的下一个位置 iter1 - iter2 计算结果为加上右边的迭代器等于左边的迭代器 > >= < <= 返回迭代器相对位置 这是由于只有vector和deque容器为其元素提供了快速、随机的访问, 确保可根据元素位置直接有效地访问指定的容器元素, 使得他们的迭代器可以有效的实现算术和关系运算 使迭代器失效的容器操作： 一些容器操作修改容器内在状态或移动容器内的元素, 会导致指向被移动的元素的迭代器失效, 也可能同时使其他迭代器失效. 使用无效的迭代器可能导致与使用空指针相同的问题 顺序容器的类型定义与操作 类型别名: size_type 无符号整型, 足以存储此容器类型最大可能容器长度 iterator 此容器类型的迭代器类型 const_iterator 元素的只读迭代器类型 reverse_iterator 按逆序寻址元素的迭代器 const_reverse_iterator 元素的只读逆序迭代器 difference_type 足够存储两个迭代器差值的有符号整型 value_type 元素类型 reference 元素的左值类型, 是 value_type& 的同义词 const_reference 元素的常量左值类型, 等效于 const value_type& begin和end成员： begin和end操作产生指向容器内第一个元素和最后一个元素的下一个位置的迭代器 c.begin() 返回一个迭代器, 指向c的第一个元素 c.end() 返回一个迭代器, 指向c的最后一个元素的下一个位置 c.rbegin() 返回一个逆序迭代器, 指向容易c的最后一个元素 c.rend() 返回一个逆序迭代器, 指向容器c的第一个元素前面的位置 每个操作均有两个版本, 如果容器是const, 则其返回类型要加上 const_ 前缀 添加元素的操作： 容器元素都是副本, 系统是将元素值复制到容器中. 被复制的原始值与新容器中的元素各不相关 c.push_back(t) 在容器c的尾部添加值为t的元素, 返回void c.push_front(t) 在容器c的前端添加值为t的元素, 只适用于list和deque容器类型, 返回void c.insert(p,t) 在迭代器p所指向的元素前面插入值为t的新元素, 返回 指向新添加元素的迭代器 c.insert(p,n,t) 在迭代器p所指向的元素前面插入n个值为t的新元素, 返回void c.insert(p,b,e) 在迭代器p所指向的元素前面插入由迭代器b和e标识范围内的元素, 返回void 注意： 1. 任何insert或push操作都可能导致迭代器失效, 当编写循环将元素插入到vector或deque容器中时, 程序必须确保迭代器在每次循环后都得到更新 2. 避免存储end操作返回的迭代器, 添加或删除deque或vector容器内的元素都会导致存储的迭代器失效. 可以在每次完成插入运算后重新计算end迭代器 顺序容器的大小操作： c.size() 返回容器c中的元素个数. 返回类型为c::size_type c.max_size() 返回容器c可容纳的的最多元素个数. 返回类型为c::size_type c.empty() 返回容器大小是否为0 c.resize(n) 调整容器c的长度大小, 使其能容纳n个元素. 如果 n<c.size() , 删除多余的元素; 否则添加初始化的新元素 c.resize(n,t) 调整容器c的长度大小, 使其能容纳n个元素. 所有新增加的元素值都为t 注意： 1. resize操作会是vector和deque的所有迭代器失效 2. 对于所有的容器类型, 如果resize操作压缩了容器, 则指向已删除的元素迭代器失效 访问元素： c.back() 返回容器c的最后一个元素的引用, 为空则此操作未定义 c.front() 返回容器c的第一个元素的引用, 为空则此操作未定义 c[n] 返回下标为n的元素的引用, 只适合vector和deque, 下标越界则未定义 c.at(n) 类似 c[n] , 但n越界会跑出out_of_range异常 if ( ! ilist . empty ()){ list < int >:: reference val = * ilist . begin (); list < int >:: reference val2 = ilist . front (); list < int >:: reference last = *-- ilist . end (); list < int >:: reference last2 = ilist . back (); } 删除元素： c.erase(p) 删除迭代器p指向的元素, 返回一个迭代器指向被删除元素后面的元素. 如果p指向最后一个元素, 则返回超出容器末端的下一个位置 c.erase(b,e) 删除迭代器b和e所标记的范围内所有的元素, 返回一个迭代器指向被删除元素后面的元素 c.clear() 删除容器c内的所有元素, 返回void c.pop_back() 删除容器c的最后一个元素, 返回void c.pop_front() 删除容器c的第一个元素, 返回void. 只适用于list或deque容器 注意： 1. pop_front和pop_back返回的不是删除元素的值, 而是void 2. erase, pop_front, pop_back函数会使指向被删除元素的所有迭代器失效. vector容器会使其后的元素迭代器失 效, deque如果删除不包含第一个或最后一个元素则所有迭代器都会失效 string searchValue ( \"abc\" ) list < string >:: iterator iter = find ( slist . begin (), slist . end (), searchValue ); if ( iter != slist . end ()) slist . erase ( iter ); 赋值与swap： c1 = c2 删除容器c1的所有元素, 然后将c2的元素复制给c1. c1和c2的类型(容器和元素类型)必须相同 c1.swap(c2) c1与c2交换内容 c.assign(b,e) 重新设置c的元素, 将迭代器b,e标识范围内的元素复制到c中 c.assign(n,t) 将容器c重新存储为n个值为t的元素 注意： 1. 与赋值相关的操作符作用于整个容器, 除了swap操作外其他操作都可以用erase和insert操作实现 2. 赋值要求容器和元素类型必须一致, 但assign可以对不同容器、不同但相互兼容的元素类型操作 3. swap要交换的容器类型和元素类型必须一致. 由于swap操作不会删除或插入任何元素, 容器内没有移动任何元 素, 因此迭代器不会失效. 如果一个迭代器iter指向svec1[3], swap运算后该迭代器指向svec2[3] slist1 = slist2 ; slist1 . assign ( slist2 . begin (), slist2 . end ()); slist1 . assign ( 10 , \"abc!\" ); capacity和reserve： capacity() 操作获取在容器需要分配更多存储空间之前能够存储的元素总数 reserve() 操作告诉vector容器应该预留多少个元素的存储空间 size() 操作指容器当前拥有的元素个数 容器选用 如果程序要求随机访问元素, 则应使用vector或deque容器 如果程序必须在容器的中间位置插入或删除元素, 则应采用list容器 如果程序不是在中间位置而是容器首部或尾部插入或删除元素, 则采用deque容器 如果读取输入时在容器中间位置插入元素, 然后需要随机访问. 可以先读入到list容器, 在复制到vector容器中 string类型 pass 容器适配器 除了顺序容器, 标准库还提供了三种顺序容器适配器: queue, priority_queue, stack 适配器 包含容器适配器、迭代器适配器和函数适配器. 本质上, 适配器是使一事物的行为类似于另一事物的行为的一种机制. 容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式实现. 例如stack适配器可使任何一种顺序容器以栈的方式工作 通用的操作和类型 size_type 一种类型, 足以存储此适配器类型最大对象的长度 value_tpye 元素类型 container_type 基础容器的类型, 适配器在此容器类型上实现 A a 创建一个新空适配器 A a(c) 创建一个新适配器, 初始化为容器c的副本 关系操作符 适配器都支持 == != < <= > >= 覆盖基础容器类型 默认的stack和queue都是基于deque容器实现的, 而priority_queue则是在vector容器上实现的 在创建适配器时, 通过将一个顺序容器指定为适配器的第二个类型实参, 可覆盖其关联的基础容器类型 对于给定适配器, 其关联容器必须满足一定的约束条件. stack 关联的基础容器可以是任意一种顺序容器类型, 因此可以建立在vector, list或deque上; queue 要求基础容器必须提供push_front运算, 因此不能建立在vector上; priority_queue 要求提供随机访问能力, 因此可以建立在vector和deque上, 不能建立在list上 stack < string , vector < string > > str_stk ; stack < string , vector < string > > str_stk ( svec ); 栈适配器 s.empty() 如果栈为空, 返回true否则false s.size() 返回栈中元素的个数 s.push(item) 在栈顶压入新元素 s.pop() 删除栈顶元素的值, 但不返回其值 s.top() 返回栈顶元素的值, 但不删除该元素 队列和优先级队列 必须包含\"queue\"头文件. queue为先入先出队列, priority_queue允许用户为队列中存储的元素设置优先级, 将元素放在比他优先级低的元素前面 q.empty() 如果队列为空, 返回true否则false q.size() 返回队列中元素的个数 q.push(item) 对于queue在队尾压入一个新元素, 在优先级队列基于优先级的适当位置插入新元素 q.pop() 删除首元素, 但不返回值 q.front() 返回队首元素的值, 但不删除. 只适用于队列 q.back() 返回队尾元素的值, 但不删除. 只适用于队列 q.top() 返回具有最高优先级的元素, 但不删除. 只适用于优先级队列","tags":"stl","loc":"http://klouse2014.github.io/stl","title":"stl学习"},{"text":"上班之后体重直接飙到了160+，白天一直坐着晚上回家累了就躺着。生活太没有规律了，我决定改变。从今天开始严格控制饮食，每天记录下吃的东西和运动量。争取一个月内有一定的变化，逐步把体重控制在130左右。 饮食 2015-05-11 早饭：蛋糕 早餐奶 中饭：玉米＋鸡蛋饼 莲花白 猪蹄 晚饭：方便面＊2 火腿肠 鸡蛋 总结 ：中饭猪蹄不该吃，晚饭不该吃方便面。今天买了红薯和紫薯，以后每天中饭晚饭都吃这些。饿了吃香蕉和酸奶。 2015-05-12 早饭：紫薯 牛奶 中饭：红薯 香蕉 晚饭：紫薯 香蕉＊3 酸奶 火腿肠 总结 ：中饭晚饭应该平均一下, 中饭吃素菜补充维生素, 晚饭不吃火腿肠. 尤其刚回家的时候特别饿，要克制住，多吃两根香蕉。加油！！ 2015-05-13 早饭：包子＊2 鸡蛋 面条汤 中饭1：紫薯 香蕉＊2 中饭2：紫薯 菠萝 香蕉 酸奶 晚饭：酸奶 香蕉 总结 ：晚上回家之后没觉得饿，少食多餐 2015-05-14 早饭：燕麦 牛奶 中饭：玉米 炒豆腐皮 木耳炒鸡蛋 晚饭：菠萝 酸奶 总结 ：晚上一点也不觉得饿了, 消化的好慢, 是该吃欺骗餐了吗。。。 2015-05-15 早饭：燕麦 牛奶 中饭：玉米 豆腐干 青菜 晚饭：红薯半个 酸奶 总结 ：晚上不会饿, 运动也还有力气。不错～ 2015-05-16 早饭：小笼包＊3 豆浆 中饭：烧饼 爆肚 小馄饨 晚饭：鸡翅＊3 总结 ：晚饭就是欺骗餐了, 每周就能这一次呀。。。 2015-05-18 早饭：燕麦 牛奶 中饭：辣子鸡 白菜炖豆腐 晚饭：玉米 香蕉＊2 总结 ：坚持！！ 运动 2015-05-11 深蹲20s＋休息10s 8组 慢走20分钟 2015-05-12 跑步小区一圈半 慢走1个小时 2015-05-13 深蹲20s＋休息10s 8组 跑步1圈 慢走1个小时 俯卧撑20个 2015-05-14 深蹲20s＋休息10s 8组 跑步1.5公里 慢走20分钟 俯卧撑30个 2015-05-15 keep 零基础适应训练 1-8 俯卧撑30个 2015-05-16 keep 零基础适应训练 2-8 快走2公里 慢跑2公里 2015-05-18 快走3公里 慢跑1公里 体重 2015-05-11 166.5斤 2015-05-12 162.6斤 怎么会轻了这么多…称坏了吗 2015-05-13 163.1斤 2015-05-14 162.1斤 2015-05-15 161.6斤 真的会瘦呀！！ 2015-05-16 161.6斤 别反弹了呀～ 2015-05-18 160.5斤 加油马上15开头了","tags":"运动","loc":"http://klouse2014.github.io/health","title":"瘦身计划"},{"text":"单链表反转 Reverse Linked List 可以通过迭代和递归两种方法实现 struct ListNode { int val ; struct ListNode * next ; }; //迭代 struct ListNode * reverseList ( struct ListNode * head ) { if ( head == NULL ) return head ; struct ListNode * p = head ; struct ListNode * q = head -> next ; head -> next = NULL ; while ( q != NULL ) { struct ListNode * s = q -> next ; q -> next = p ; p = q ; q = s ; } return p ; } //递归 struct ListNode * reverseList ( struct ListNode * head ) { if ( head == NULL || head -> next == NULL ) return head ; struct ListNode * q = reverseList ( head -> next ); head -> next -> next = head ; head -> next = NULL ; return q ; } 质数问题 Count Primes 在生成质数序列时, 可以如下考虑： 在判断一个数是否是质数时, 会看是否能被比他小的其他整数整除 由于非质数一定能由小于等于它的质数相乘得到, 因此仅需测试比此数小的所有质数是否是乘数因子即可 同时在判断是否是乘数因子时, 仅需判断小于等于sqrt(x)的质数即可, 避免造成重复测试 #include \"iostream\" #include \"vector\" using namespace std ; int countPrimes ( int n ) { vector < int > primeList ; primeList . push_back ( 2 ); int i = 3 ; while ( i <= n ) { //选择乘数中较小的一个测试 bool isPrime = true ; vector < int >:: iterator iter = primeList . begin (); for (; iter != primeList . end () && * iter * * iter <= i ; iter ++ ) { //遍历之前的质数, 均不能被整除就是下一个质数 if ( i % * iter == 0 ) { isPrime = false ; break ; } } if ( isPrime == true ) primeList . push_back ( i ); ++ i ; } for ( int i = 0 ; i < primeList . size (); i ++ ) cout << primeList [ i ] << \" \" ; cout << endl ; return primeList . size (); } int main () { int n ; while ( cin >> n ) cout << countPrimes ( n ) << endl ;; return 0 ; } 但是代码提交后报计算次数过多, 复杂度是O(n n)。后面看了提示用了一种 Sieve of Eratosthenes 的算法,复杂度在O(n 2) 首先将 2~n 的整数列出来, 然后从 p=2 开始依次将 p*1,2,3... 的数剔除 然后让 p 等于下一个未被去除的整数,继续剔除 直到列表中找不到比此循环中 p 值更大的数为止, 剩下的数都是质数 因为是连续查找整数, 为了提高空间利用率, 使用位图实现 #include \"iostream\" #include \"vector\" using namespace std ; void setBitMap ( char * bitmap , int pos ) { //将将位图第pos位置为1 bitmap [ pos >> 3 ] |= ( 1 << ( pos % 8 )); } void resetBitMap ( char * bitmap , int pos ) { //将位图第pos位置为0 bitmap [ pos >> 3 ] &= ~ ( 1 << ( pos % 8 )); } bool testBitMap ( char * bitmap , int pos ) { //测试位图第pos位置是否为1 return bitmap [ pos >> 3 ] & ( 1 << ( pos % 8 )); } int countPrimes_SOE ( int n ) { int len = ( n >> 3 ) + 1 ; char * numList = new char [ len ]; vector < int > primeList ; for ( int i = 0 ; i < n ; i ++ ) setBitMap ( numList , i ); resetBitMap ( numList , 0 ); int index = 1 ; while ( index < n ) { int temp = index + 1 ; if ( testBitMap ( numList , index )) { primeList . push_back ( temp ); for ( int i = 2 ; i * temp <= n ; i ++ ) { if ( testBitMap ( numList , i * temp - 1 )) resetBitMap ( numList , i * temp - 1 ); } } ++ index ; } for ( int i = 0 ; i < primeList . size (); i ++ ) cout << primeList [ i ] << \" \" ; cout << endl ; delete numList ; return primeList . size (); } int main () { int n ; while ( cin >> n ) cout << countPrimes_SOE ( n ) << endl ; return 0 ; } 根据给定有序数组生成平衡二叉树 Convert Sorted Array to Binary Search Tree 通过递归实现, 当长度为0时返回 NULL 子函数返回子平衡二叉树 中值作为根节点连接前后两个子平衡树 struct TreeNode * sortedArrayToBST ( int * nums , int numsSize ) { if ( numsSize == 0 ) return NULL ; int rootNum = numsSize >> 1 ; struct TreeNode * root = ( struct TreeNode * ) malloc ( sizeof ( struct TreeNode )); root -> val = nums [ rootNum ]; root -> left = sortedArrayToBST ( nums , rootNum ); root -> right = sortedArrayToBST ( nums + rootNum + 1 , numsSize - rootNum - 1 ); return root ; } 给定数组，查找数组中是否存在一对相加和为给定数的数对 Two Sum 考虑到如果存在相同的数字，如果使用hash字典纪录索引信息会造成相同键值覆盖的问题。因此通过定义一个结构体来记录数值＋索引 按结构体中的数值排序后，按照排序后数组查找指定和的数值对的方法查找。空间复杂度为O(n), 时间复杂度为O(nlgn) #include \"stdio.h\" #include \"string.h\" struct elem { int value ; int index ; }; int cmp ( const void * vp1 , const void * vp2 ) { return ( * ( struct elem * ) vp1 ). value - ( * ( struct elem * ) vp2 ). value ; } int * twoSum ( int * nums , int numsSize , int target ) { struct elem * list = ( struct elem * ) malloc ( numsSize * sizeof ( struct elem )); memset ( list , '\\0' , numsSize * sizeof ( struct elem )); int * result = ( int * ) malloc ( sizeof ( int ) * 2 ); int i = 0 ; for (; i < numsSize ; i ++ ) { list [ i ]. value = nums [ i ]; list [ i ]. index = i + 1 ; } qsort ( list , numsSize , sizeof ( struct elem ), cmp ); struct elem * first = list , * last = list + numsSize - 1 ; while ( first < last ) { if ( first -> value + last -> value > target ) -- last ; else if ( first -> value + last -> value < target ) ++ first ; else { result [ 0 ] = first -> index < last -> index ? first -> index : last -> index ; result [ 1 ] = first -> index > last -> index ? first -> index : last -> index ; free ( list ); return result ; } } free ( list ); return NULL ; } 链表数字相加 Add Two Numbers 由于链表是从低位向高位，因此做法类似大数加法 主要处理好边界和异常检查 #include \"iostream\" using namespace std ; struct ListNode { int val ; ListNode * next ; }; struct ListNode * addTwoNumbers ( struct ListNode * l1 , struct ListNode * l2 ) { if ( l1 == NULL || l2 == NULL ) return NULL ; int pre = 0 ; ListNode * root = ( ListNode * ) malloc ( sizeof ( ListNode )); root -> val = ( l1 -> val + l2 -> val ) % 10 ; root -> next = NULL ; pre = ( l1 -> val + l2 -> val ) / 10 ; l1 = l1 -> next ; l2 = l2 -> next ; ListNode * p = root , * q = NULL ; while ( l1 != NULL && l2 != NULL ) { q = ( ListNode * ) malloc ( sizeof ( ListNode )); q -> val = ( l1 -> val + l2 -> val + pre ) % 10 ; q -> next = NULL ; pre = ( l1 -> val + l2 -> val + pre ) / 10 ; p -> next = q ; p = q ; l1 = l1 -> next ; l2 = l2 -> next ; } while ( l1 != NULL ) { q = ( ListNode * ) malloc ( sizeof ( ListNode )); q -> val = ( l1 -> val + pre ) % 10 ; q -> next = NULL ; pre = ( l1 -> val + pre ) / 10 ; p -> next = q ; p = q ; l1 = l1 -> next ; } while ( l2 != NULL ) { q = ( ListNode * ) malloc ( sizeof ( ListNode )); q -> val = ( l2 -> val + pre ) % 10 ; q -> next = NULL ; pre = ( l2 -> val + pre ) / 10 ; p -> next = q ; p = q ; l2 = l2 -> next ; } if ( pre > 0 ) { q = ( ListNode * ) malloc ( sizeof ( ListNode )); q -> val = pre % 10 ; q -> next = NULL ; p -> next = q ; } return root ; } 结尾单词长度 Length of Last Word 需要注意当空格结尾时, 应跳过空格查找最后一个单词的长度 int lengthOfLastWord ( char * s ) { if ( NULL == s || 0 == strlen ( s )) return 0 ; char * p = s + strlen ( s ) - 1 ; while ( * p == ' ' && p >= s ) -- p ; int lastLen = 0 ; while ( p >= s ) { if ( * p == ' ' ) break ; -- p ; ++ lastLen ; } return lastLen ; } 查找相交链表第一个交点 Intersection of Two Linked Lists 得到两条链表长度 如果相交的话, 从两条链表距离结尾相同位置的节点开始向后查找时。一定会遇到指向相同节点的时刻, 即为第一个交点 struct ListNode * getIntersectionNode ( struct ListNode * headA , struct ListNode * headB ) { if ( NULL == headA || NULL == headB ) return NULL ; struct ListNode * p = headA , * q = headB ; int i = 0 , j = 0 ; while ( p != NULL ) { i ++ ; p = p -> next ; } while ( q != NULL ) { j ++ ; q = q -> next ; } while ( i > j ) { headA = headA -> next ; i -- ; } while ( j > i ) { headB = headB -> next ; j -- ; } while ( headA != NULL ) { if ( headA == headB ) return headA ; headA = headA -> next ; headB = headB -> next ; } return NULL ; } 同型字符串 Isomorphic Strings 可以将字符串按照每个字符第一次出现的索引进行重新编码 egg -> 011 paper -> 01034 这样同型字符串会被转化成相同的编码, 比较编码是否相等即可 #include \"iostream\" #include \"string\" #include \"vector\" #include \"map\" using namespace std ; bool isIsomorphic ( string s , string t ) { vector < int > checkList ; map < int , int > firstPosDict ; map < int , int >:: iterator iter ; for ( string :: size_type i = 0 ; i < s . size (); i ++ ) { iter = firstPosDict . find ( s [ i ]); if ( iter == firstPosDict . end ()) firstPosDict [ s [ i ]] = i ; checkList . push_back ( firstPosDict [ s [ i ]]); } firstPosDict . clear (); for ( string :: size_type i = 0 ; i < t . size (); i ++ ) { iter = firstPosDict . find ( t [ i ]); if ( iter == firstPosDict . end ()) firstPosDict [ t [ i ]] = i ; if ( checkList [ i ] != firstPosDict [ t [ i ]]) return false ; } return true ; }","tags":"算法","loc":"http://klouse2014.github.io/interview_leetCode","title":"leetCode笔记"},{"text":"把一个字符串转化为整数 需要考虑以下几点： 1. 字符串开头：正负号需记下来, 开头连续为0的位应该跳过; 负号后紧跟0报错 2. 字符串中异常字符：非0～9数字应该报错 3. 当转化数字超出int边界时，应该报错 #include \"iostream\" using namespace std ; #define MAX 0x7fffffff #define MIN 0x80000000 //字符合法性检查 bool charIsOk ( char c ) { if ( c > '9' || c < '0' ) return false ; else return true ; } //将输入字符串转化为整数输出 int StrToInt ( char * str , char * errMsg ) { if ( str == NULL ) { strcpy ( errMsg , \"传入指针为空\" ); return - 1 ; } //字符串开头检查 int sign = 1 ; int result = 0 , i = 0 ; if ( str [ 0 ] == '-' ) { sign = - 1 ; if ( str [ 1 ] == '0' ) { strcpy ( errMsg , \"负号后不能跟0\" ); return - 1 ; } i ++ ; } if ( str [ 0 ] == '+' ) i ++ ; if ( str [ 0 ] != '+' && str [ 0 ] != '-' && ! charIsOk ( str [ 0 ])) { strcpy ( errMsg , \"字符串开头异常\" ); return - 1 ; } bool isStart = false ; for (; i < strlen ( str ); i ++ ) { if ( str [ i ] == '0' && ! isStart ) continue ; if ( ! charIsOk ( str [ i ])) { //合法性检查 strcpy ( errMsg , \"字符串内容异常\" ); return - 1 ; } if ( str [ i ] != '0' || isStart ) { isStart = true ; //需检查是否溢出 if ( 1 == sign && ( int ( MAX ) - ( str [ i ] - '0' )) / 10 < result ) { strcpy ( errMsg , \"字符表示数字溢出\" ); return - 1 ; } if ( - 1 == sign && ( int ( MIN ) + ( str [ i ] - '0' )) / 10 > result * sign ) { strcpy ( errMsg , \"字符串表示数据溢出\" ); return - 1 ; } result = result * 10 + str [ i ] - '0' ; } } if ( result != 0 && sign == - 1 ) result *= sign ; return result ; } int main () { cout << int ( MAX ) << \" \" << int ( MIN ) << endl ; char str [ 100 ] = { 0 }, err [ 30 ] = { 0 }; cin >> str ; int output = StrToInt ( str , err ); if ( strlen ( err ) != 0 ) cout << err << endl ; else cout << output << endl ; return 0 ; } 大数加法 I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. A,B must be positive. #include \"iostream\" #include \"string.h\" using namespace std ; #define MAXLEN 1001 char first [ MAXLEN ], second [ MAXLEN ], result [ MAXLEN + 1 ]; void strPlus () { int index = max ( strlen ( first ), strlen ( second )); int i = strlen ( first ) - 1 ; int j = strlen ( second ) - 1 ; if ( i < 0 || j < 0 ) return ; int pre = 0 ; int total = 0 ; while ( i >= 0 && j >= 0 ) { total = first [ i -- ] - '0' + second [ j -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } while ( i >= 0 ) { total = first [ i -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } while ( j >= 0 ) { total = second [ j -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } if ( pre > 0 ) result [ 0 ] = pre + '0' ; else memmove ( result , result + 1 , MAXLEN ); } int main () { int times = 0 , i = 1 ; cin >> times ; while ( i <= times ) { memset ( first , '\\0' , sizeof ( first )); memset ( second , '\\0' , sizeof ( second )); memset ( result , '\\0' , sizeof ( result )); cin >> first >> second ; strPlus (); cout << \"Case \" << i ++ << \":\" << endl ; cout << first << \" + \" << second << \" = \" << result << endl ; } return 0 ; } 带小数的大数加法 输入包含两个正数A,B（可能为小数且位数不大于400） 输出A+B的结果，结果需要是最简的形式 需要考虑以下几点： 1. 带小数的加法，需要按小数点位置对齐 2. 输出结果小数点后面0结尾或小数点的部分应被舍去 #include \"iostream\" #include \"string.h\" using namespace std ; #define max 1000 char fst [ max ], sec [ max ], result [ max * 2 ]; void bigFloatPlus () { int len_fst = strlen ( fst ); int len_sec = strlen ( sec ); int dotPos1 = 0 , dotPos2 = 0 ; while ( dotPos1 < len_fst ) { if ( '.' == fst [ dotPos1 ]) break ; dotPos1 ++ ; } while ( dotPos2 < len_sec ) { if ( '.' == sec [ dotPos2 ]) break ; dotPos2 ++ ; } //如果输入为整数, 在后面添加小数点便于循环 if ( dotPos1 == len_fst ) { fst [ dotPos1 ] = '.' ; fst [ dotPos1 + 1 ] = '0' ; fst [ dotPos1 + 2 ] = '\\0' ; len_fst += 2 ; } if ( dotPos2 == len_sec ) { sec [ dotPos2 ] = '.' ; sec [ dotPos2 + 1 ] = '0' ; sec [ dotPos2 + 2 ] = '\\0' ; len_sec += 2 ; } //将小数点后面位数较多的部分直接复制 int len1 = len_fst - 1 - dotPos1 ; int len2 = len_sec - 1 - dotPos2 ; int i = len_fst - 1 , j = len_sec - 1 ; int index = sizeof ( result ) - 2 ; if ( len1 > len2 ) { memcpy ( result + index - ( len1 - len2 - 1 ), fst + i - ( len1 - len2 - 1 ), len1 - len2 ); i -= len1 - len2 ; index -= len1 - len2 ; } if ( len1 < len2 ) { memcpy ( result + index - ( len2 - len1 - 1 ), sec + j - ( len2 - len1 - 1 ), len2 - len1 ); j -= len2 - len1 ; index -= len2 - len1 ; } int pre = 0 , tmp = 0 ; while ( i >= 0 && j >= 0 ) { if ( '.' == fst [ i ]) { result [ index -- ] = '.' ; i -- ; j -- ; continue ; } tmp = pre + fst [ i -- ] - '0' + sec [ j -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } while ( i >= 0 ) { if ( '.' == fst [ i ]) { result [ index -- ] = '.' ; i -- ; continue ; } tmp = pre + fst [ i -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } while ( j >= 0 ) { if ( '.' == sec [ j ]) { result [ index -- ] = '.' ; j -- ; continue ; } tmp = pre + sec [ j -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } if ( pre > 0 ) result [ index -- ] = pre + '0' ; int tail = sizeof ( result ) - 2 ; while ( tail > index ) { if ( result [ tail ] != '0' && result [ tail ] != '.' ) break ; else tail -- ; } result [ tail + 1 ] = '\\0' ; memmove ( result , result + index + 1 , tail - index ); } int main () { memset ( fst , '\\0' , sizeof ( fst )); memset ( sec , '\\0' , sizeof ( sec )); while ( cin >> fst >> sec ) { memset ( result , '\\0' , sizeof ( result )); bigFloatPlus (); cout << result << endl ; } return 0 ; }","tags":"算法","loc":"http://klouse2014.github.io/interview_bignum","title":"大数问题"},{"text":"发现很多shell命令看完之后不用渐渐就忘了, 因此把常用的命令总结一下后面有遇到的再更新。 常用命令 find find [path] [options] [tests] [actions] path为绝对路径或相对路径 option选项 -maxdepths N 最多搜索N层目录 tests提供多种测试, 按顺序应用到搜索上, false跳过, true对当前文件采取actions -name pattern 文件名模式匹配 -newer file1 ! file2 比指定file1新, file2旧的文件 -type d/f 为目录/文件 -mtime +n/-n 按照文件更改时间来查找文件, -n表示更改时间距现在n天以内, +n表示更改时间在n天以前 -mmin n 最后n分钟更改的文件 -empty 文件为空 -a/-and 两个测试必须为真, -o/-or 其中一个为真, !/-not 取反 可通过括号增加测试优先级, 前面需加\\ actions为执行语句 -exec -ok 必须以\\;结尾。ok会在执行前询问,使用{}传入后会被当前文件的完整路径取代 -print 打印文件名 grep grep [options] PATTERN [files] 用于在文件中搜索字符串 options选项 -c 输出匹配行的数目，而不是输出匹配的行 -E 启动拓展表达式 -i 忽略大小写 -l 只列出包含匹配行的文件名，而不输出真正的匹配行 -v 对匹配模式取反，即搜索不匹配行而不是匹配行 -n 打印包含匹配项的行和行标 test test expression or [ expression ] 字符串 =/!= 是否相等 -n/-z 是否为空 算术比较 -eq -ne -gt -ge -lt -le ! 文件 -e 存在 -f 存在并且是文件 -d 存在并且是目录 –w/v/x 可读/写/执行 cut -f 按字段 -c 按字符 -b 按字节 -d 设置分割符 N-M, N设置输出范围 mkdir -p 或 —parents 表示若所要创建的目录的上层目录没有创建，则会一并创建上层目录 -m 指定目录的权限 mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a} tree project/ project/ |-- bin |-- demo | `-- stat | `-- a |-- doc | |-- html | |-- info | `-- pdf |-- lib | `-- ext `-- src comm 比较两个已排序的文件。在缺省情况下将三栏输出写到标准输出。这些栏由以下内容组成：只在 File1 中的行、只在 File2 中的行、既在 File1，又在 File2 中的行 comm [-123] [File1] [File2] -1 不显示只在第1个文件里出现过的列 -2 不显示只在第2个文件里出现过的列 -3 不显示只在第1和第2个文件里出现过的列 expr 或 $((…)) 将它的参数作为一个表达式来求值 x = `expr $x + 1` `…` 或 $(…) 执行中间的语句, 结果就是命令的输出，而不是该命令的退出状态。将它的字符串形式的输出结果 ${…} 为保护变量名中类似$i部分的扩展，需将其放入花括号中 ${param:-default} 当param为空时将它设置为default ${#param} 给出param的长度 ${param%word} 从param尾部开始删除与word匹配的最小部分，返回剩余部分 ${param%%word} 从param尾部开始删除与word匹配的最长部分，返回剩余部分 ${param#word} 从param头部开始删除与word匹配的最小部分，返回剩余部分 ${param##word} 从param头部开始删除与word匹配的最长部分，返回剩余部分 for或while 双括号形式，注意与算术计算$((…))区分 for((i=1;i<100;i++;));do ... done while((i<100));do ... done for in 形式 for file in `ls *` while 中括号形式 while [ $ i -le $ max ];do ... done Here Document Here Document 是在Linux Shell 中的一种特殊的重定向方式，它的基本的形式如下 cmd << delimiter Here Document Content delimiter 这里要注意, delimiter 只是一个标识而已，可以替换成任意的合法字符 在Here Document 的内容中，不仅可以包括普通的字符，还可以在里面使用变量，例如 cat << EOF > output.sh echo \"This is output\" echo $1 EOF 使用sh here.sh HereDocument 运行脚本得到output.sh的内容 echo \"This is output\" echo HereDocument 在这里 $1 被展开成为了脚本的参数 HereDocument 还有一个用法就是将 << 变为 <<- , 这样唯一变化就是Here Document 的内容部分每行前面的 tab (制表符)将会被删除掉，方便阅读代码 tar 可以归档多个文件和目录到一个.tar文件下，还可以从一个归档文件中抽取一个文件和目录。 tar [-c][-r][-t][-x][-v][-z][f 文件名] 文件和目录名 -c 创建归档文件 -r 增加文件到归档文件中 -t 查看归档文件中的文件 -x 解开归档文件 -v 显示冗长信息 -z 用gzip对存档压缩或解压 tar –czvf back.tar.gz 文件1 目录1 文件2 tar –xzvf back.tar.gz sort 对文件进行排序。 sort [OPTION]... [FILE]... -u 在输出中去除重复的行 -r sort默认是升序排列, -r为降序排列 -o 重定向到文件, 可以使用原文件 -n 以数值进行排序 -t -k -t用于设置分隔符, -k用来指定排序的列数 $ sort -n -t ' ' -k 3r -k 2 facebook.txt baidu 100 5000 google 110 5000 sohu 100 4500 guge 50 3000 uniq 检查重复的行 uniq [-c | -d | -u] [-i] [-f num] [-s chars] [input_file [output_file]] -c, —count 在每行前显示该行重复次数 -d, —repeated 只输出重复的行 -D, —all-repeated 只输出重复的行，不过有几行输出几行 -f, —skip-fields=N -f 忽略的段数，-f 1 忽略第一段 -i, —ignore-case 不区分大小写 -s, —skip-chars=N 根-f有点像，不过-s是忽略，后面多少个字符 -s 5就忽略后面5个字符 -u, —unique 去除重复的后，全部显示出来，根mysql的distinct功能上有点像","tags":"Linux","loc":"http://klouse2014.github.io/shell+command","title":"shell命令备忘"},{"text":"开始吧 github准备 创建username.github.io 数据仓库 pelican准备 新建blog文件件, 执行pelican-quickstart命令创建基本框架 将output文件夹绑定到数据仓库 cd output git init git remote add origin https://github.com/username/username.github.io.git git pull origin master pelican 包含很多主题和插件，可以直接clone使用 pelican-themes pelican-plugins 本例使用 elegant 主题 elegant主题说明文档 生成网页文件以及在本机上测试 make html make serve 注意事项 增加评论功能 Pelican 使用Disqus评论, 可以申请在Disqus上申请一个站点, 然后在pelicanconf.py里添加或修改DISQUS_SITENAME项: DISQUS_SITENAME = u\"xxxxx\" 参考资料 pelican官方说明文档 配置文件参考","tags":"Pelican","loc":"http://klouse2014.github.io/GitHub+Pelican","title":"使用GitHub＋Pelican搭建个人博客"}]}