{"pages":[{"text":"上班之后体重直接飙到了160+，白天一直坐着晚上回家累了就躺着。生活太没有规律了，我决定改变。从今天开始严格控制饮食，每天记录下吃的东西和运动量。争取一个月内有一定的变化，逐步把体重控制在130左右。 饮食 2015-05-11 早饭：蛋糕 早餐奶 中饭：玉米＋鸡蛋饼 莲花白 猪蹄 晚饭：方便面＊2 火腿肠 鸡蛋 总结 ：中饭猪蹄不该吃，晚饭不该吃方便面。今天买了红薯和紫薯，以后每天中饭晚饭都吃这些。饿了吃香蕉和酸奶。 2015-05-12 早饭：紫薯 牛奶 中饭：红薯 香蕉 晚饭：紫薯 香蕉＊3 酸奶 火腿肠 总结 ：中饭晚饭应该平均一下, 中饭吃素菜补充维生素, 晚饭不吃火腿肠. 尤其刚回家的时候特别饿，要克制住，多吃两根香蕉。加油！！ 运动 2015-05-11 深蹲20s＋休息10s 8组 慢走20分钟 2015-05-12 跑步小区一圈半 慢走1个小时 体重 2015-05-11 166.5斤 2015-05-12 162.6斤 怎么会轻了这么多…称坏了吗","tags":"运动","loc":"http://klouse2014.github.io/health","title":"瘦身计划"},{"text":"单链表反转 Reverse Linked List 可以通过迭代和递归两种方法实现 struct ListNode { int val ; struct ListNode * next ; }; //迭代 struct ListNode * reverseList ( struct ListNode * head ) { if ( head == NULL ) return head ; struct ListNode * p = head ; struct ListNode * q = head -> next ; head -> next = NULL ; while ( q != NULL ) { struct ListNode * s = q -> next ; q -> next = p ; p = q ; q = s ; } return p ; } //递归 struct ListNode * reverseList ( struct ListNode * head ) { if ( head == NULL || head -> next == NULL ) return head ; struct ListNode * q = reverseList ( head -> next ); head -> next -> next = head ; head -> next = NULL ; return q ; } 质数问题 Count Primes 在生成质数序列时, 可以如下考虑： 在判断一个数是否是质数时, 会看是否能被比他小的其他整数整除 由于非质数一定能由小于等于它的质数相乘得到, 因此仅需测试比此数小的所有质数是否是乘数因子即可 同时在判断是否是乘数因子时, 仅需判断小于等于sqrt(x)的质数即可, 避免造成重复测试 #include \"iostream\" #include \"vector\" using namespace std ; int countPrimes ( int n ) { vector < int > primeList ; primeList . push_back ( 2 ); int i = 3 ; while ( i <= n ) { //选择乘数中较小的一个测试 bool isPrime = true ; vector < int >:: iterator iter = primeList . begin (); for (; iter != primeList . end () && * iter * * iter <= i ; iter ++ ) { //遍历之前的质数, 均不能被整除就是下一个质数 if ( i % * iter == 0 ) { isPrime = false ; break ; } } if ( isPrime == true ) primeList . push_back ( i ); ++ i ; } for ( int i = 0 ; i < primeList . size (); i ++ ) cout << primeList [ i ] << \" \" ; cout << endl ; return primeList . size (); } int main () { int n ; while ( cin >> n ) cout << countPrimes ( n ) << endl ;; return 0 ; } 但是代码提交后报计算次数过多, 复杂度是O(n n)。后面看了提示用了一种 Sieve of Eratosthenes 的算法,复杂度在O(n 2) 首先将 2~n 的整数列出来, 然后从 p=2 开始依次将 p*1,2,3... 的数剔除 然后让 p 等于下一个未被去除的整数,继续剔除 直到列表中找不到比此循环中 p 值更大的数为止, 剩下的数都是质数 因为是连续查找整数, 为了提高空间利用率, 使用位图实现 #include \"iostream\" #include \"vector\" using namespace std ; void setBitMap ( char * bitmap , int pos ) { //将将位图第pos位置为1 bitmap [ pos >> 3 ] |= ( 1 << ( pos % 8 )); } void resetBitMap ( char * bitmap , int pos ) { //将位图第pos位置为0 bitmap [ pos >> 3 ] &= ~ ( 1 << ( pos % 8 )); } bool testBitMap ( char * bitmap , int pos ) { //测试位图第pos位置是否为1 return bitmap [ pos >> 3 ] & ( 1 << ( pos % 8 )); } int countPrimes_SOE ( int n ) { int len = ( n >> 3 ) + 1 ; char * numList = new char [ len ]; vector < int > primeList ; for ( int i = 0 ; i < n ; i ++ ) setBitMap ( numList , i ); resetBitMap ( numList , 0 ); int index = 1 ; while ( index < n ) { int temp = index + 1 ; if ( testBitMap ( numList , index )) { primeList . push_back ( temp ); for ( int i = 2 ; i * temp <= n ; i ++ ) { if ( testBitMap ( numList , i * temp - 1 )) resetBitMap ( numList , i * temp - 1 ); } } ++ index ; } for ( int i = 0 ; i < primeList . size (); i ++ ) cout << primeList [ i ] << \" \" ; cout << endl ; delete numList ; return primeList . size (); } int main () { int n ; while ( cin >> n ) cout << countPrimes_SOE ( n ) << endl ; return 0 ; } 根据给定有序数组生成平衡二叉树 Convert Sorted Array to Binary Search Tree 通过递归实现, 当长度为0时返回 NULL 子函数返回子平衡二叉树 中值作为根节点连接前后两个子平衡树 struct TreeNode * sortedArrayToBST ( int * nums , int numsSize ) { if ( numsSize == 0 ) return NULL ; int rootNum = numsSize >> 1 ; struct TreeNode * root = ( struct TreeNode * ) malloc ( sizeof ( struct TreeNode )); root -> val = nums [ rootNum ]; root -> left = sortedArrayToBST ( nums , rootNum ); root -> right = sortedArrayToBST ( nums + rootNum + 1 , numsSize - rootNum - 1 ); return root ; } 给定数组，查找数组中是否存在一对相加和为给定数的数对 Two Sum 考虑到如果存在相同的数字，如果使用hash字典纪录索引信息会造成相同键值覆盖的问题。因此通过定义一个结构体来记录数值＋索引 按结构体中的数值排序后，按照排序后数组查找指定和的数值对的方法查找。空间复杂度为O(n), 时间复杂度为O(nlgn) #include \"stdio.h\" #include \"string.h\" struct elem { int value ; int index ; }; int cmp ( const void * vp1 , const void * vp2 ) { return ( * ( struct elem * ) vp1 ). value - ( * ( struct elem * ) vp2 ). value ; } int * twoSum ( int * nums , int numsSize , int target ) { struct elem * list = ( struct elem * ) malloc ( numsSize * sizeof ( struct elem )); memset ( list , '\\0' , numsSize * sizeof ( struct elem )); int * result = ( int * ) malloc ( sizeof ( int ) * 2 ); int i = 0 ; for (; i < numsSize ; i ++ ) { list [ i ]. value = nums [ i ]; list [ i ]. index = i + 1 ; } qsort ( list , numsSize , sizeof ( struct elem ), cmp ); struct elem * first = list , * last = list + numsSize - 1 ; while ( first < last ) { if ( first -> value + last -> value > target ) -- last ; else if ( first -> value + last -> value < target ) ++ first ; else { result [ 0 ] = first -> index < last -> index ? first -> index : last -> index ; result [ 1 ] = first -> index > last -> index ? first -> index : last -> index ; free ( list ); return result ; } } free ( list ); return NULL ; } 链表数字相加 Add Two Numbers 由于链表是从低位向高位，因此做法类似大数加法 主要处理好边界和异常检查 #include \"iostream\" using namespace std ; struct ListNode { int val ; ListNode * next ; }; struct ListNode * addTwoNumbers ( struct ListNode * l1 , struct ListNode * l2 ) { if ( l1 == NULL || l2 == NULL ) return NULL ; int pre = 0 ; ListNode * root = ( ListNode * ) malloc ( sizeof ( ListNode )); root -> val = ( l1 -> val + l2 -> val ) % 10 ; root -> next = NULL ; pre = ( l1 -> val + l2 -> val ) / 10 ; l1 = l1 -> next ; l2 = l2 -> next ; ListNode * p = root , * q = NULL ; while ( l1 != NULL && l2 != NULL ) { q = ( ListNode * ) malloc ( sizeof ( ListNode )); q -> val = ( l1 -> val + l2 -> val + pre ) % 10 ; q -> next = NULL ; pre = ( l1 -> val + l2 -> val + pre ) / 10 ; p -> next = q ; p = q ; l1 = l1 -> next ; l2 = l2 -> next ; } while ( l1 != NULL ) { q = ( ListNode * ) malloc ( sizeof ( ListNode )); q -> val = ( l1 -> val + pre ) % 10 ; q -> next = NULL ; pre = ( l1 -> val + pre ) / 10 ; p -> next = q ; p = q ; l1 = l1 -> next ; } while ( l2 != NULL ) { q = ( ListNode * ) malloc ( sizeof ( ListNode )); q -> val = ( l2 -> val + pre ) % 10 ; q -> next = NULL ; pre = ( l2 -> val + pre ) / 10 ; p -> next = q ; p = q ; l2 = l2 -> next ; } if ( pre > 0 ) { q = ( ListNode * ) malloc ( sizeof ( ListNode )); q -> val = pre % 10 ; q -> next = NULL ; p -> next = q ; } return root ; } 结尾单词长度 Length of Last Word 需要注意当空格结尾时, 应跳过空格查找最后一个单词的长度 int lengthOfLastWord ( char * s ) { if ( NULL == s || 0 == strlen ( s )) return 0 ; char * p = s + strlen ( s ) - 1 ; while ( * p == ' ' && p >= s ) -- p ; int lastLen = 0 ; while ( p >= s ) { if ( * p == ' ' ) break ; -- p ; ++ lastLen ; } return lastLen ; } 查找相交链表第一个交点 Intersection of Two Linked Lists 得到两条链表长度 如果相交的话, 从两条链表距离结尾相同位置的节点开始向后查找时。一定会遇到指向相同节点的时刻, 即为第一个交点 struct ListNode * getIntersectionNode ( struct ListNode * headA , struct ListNode * headB ) { if ( NULL == headA || NULL == headB ) return NULL ; struct ListNode * p = headA , * q = headB ; int i = 0 , j = 0 ; while ( p != NULL ) { i ++ ; p = p -> next ; } while ( q != NULL ) { j ++ ; q = q -> next ; } while ( i > j ) { headA = headA -> next ; i -- ; } while ( j > i ) { headB = headB -> next ; j -- ; } while ( headA != NULL ) { if ( headA == headB ) return headA ; headA = headA -> next ; headB = headB -> next ; } return NULL ; } 同型字符串 Isomorphic Strings 可以将字符串按照每个字符第一次出现的索引进行重新编码 egg -> 011 paper -> 01034 这样同型字符串会被转化成相同的编码, 比较编码是否相等即可 #include \"iostream\" #include \"string\" #include \"vector\" #include \"map\" using namespace std ; bool isIsomorphic ( string s , string t ) { vector < int > checkList ; map < int , int > firstPosDict ; map < int , int >:: iterator iter ; for ( string :: size_type i = 0 ; i < s . size (); i ++ ) { iter = firstPosDict . find ( s [ i ]); if ( iter == firstPosDict . end ()) firstPosDict [ s [ i ]] = i ; checkList . push_back ( firstPosDict [ s [ i ]]); } firstPosDict . clear (); for ( string :: size_type i = 0 ; i < t . size (); i ++ ) { iter = firstPosDict . find ( t [ i ]); if ( iter == firstPosDict . end ()) firstPosDict [ t [ i ]] = i ; if ( checkList [ i ] != firstPosDict [ t [ i ]]) return false ; } return true ; }","tags":"算法","loc":"http://klouse2014.github.io/interview_leetCode","title":"leetCode笔记"},{"text":"把一个字符串转化为整数 需要考虑以下几点： 1. 字符串开头：正负号需记下来, 开头连续为0的位应该跳过; 负号后紧跟0报错 2. 字符串中异常字符：非0～9数字应该报错 3. 当转化数字超出int边界时，应该报错 #include \"iostream\" using namespace std ; #define MAX 0x7fffffff #define MIN 0x80000000 //字符合法性检查 bool charIsOk ( char c ) { if ( c > '9' || c < '0' ) return false ; else return true ; } //将输入字符串转化为整数输出 int StrToInt ( char * str , char * errMsg ) { if ( str == NULL ) { strcpy ( errMsg , \"传入指针为空\" ); return - 1 ; } //字符串开头检查 int sign = 1 ; int result = 0 , i = 0 ; if ( str [ 0 ] == '-' ) { sign = - 1 ; if ( str [ 1 ] == '0' ) { strcpy ( errMsg , \"负号后不能跟0\" ); return - 1 ; } i ++ ; } if ( str [ 0 ] == '+' ) i ++ ; if ( str [ 0 ] != '+' && str [ 0 ] != '-' && ! charIsOk ( str [ 0 ])) { strcpy ( errMsg , \"字符串开头异常\" ); return - 1 ; } bool isStart = false ; for (; i < strlen ( str ); i ++ ) { if ( str [ i ] == '0' && ! isStart ) continue ; if ( ! charIsOk ( str [ i ])) { //合法性检查 strcpy ( errMsg , \"字符串内容异常\" ); return - 1 ; } if ( str [ i ] != '0' || isStart ) { isStart = true ; //需检查是否溢出 if ( 1 == sign && ( int ( MAX ) - ( str [ i ] - '0' )) / 10 < result ) { strcpy ( errMsg , \"字符表示数字溢出\" ); return - 1 ; } if ( - 1 == sign && ( int ( MIN ) + ( str [ i ] - '0' )) / 10 > result * sign ) { strcpy ( errMsg , \"字符串表示数据溢出\" ); return - 1 ; } result = result * 10 + str [ i ] - '0' ; } } if ( result != 0 && sign == - 1 ) result *= sign ; return result ; } int main () { cout << int ( MAX ) << \" \" << int ( MIN ) << endl ; char str [ 100 ] = { 0 }, err [ 30 ] = { 0 }; cin >> str ; int output = StrToInt ( str , err ); if ( strlen ( err ) != 0 ) cout << err << endl ; else cout << output << endl ; return 0 ; } 大数加法 I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. A,B must be positive. #include \"iostream\" #include \"string.h\" using namespace std ; #define MAXLEN 1001 char first [ MAXLEN ], second [ MAXLEN ], result [ MAXLEN + 1 ]; void strPlus () { int index = max ( strlen ( first ), strlen ( second )); int i = strlen ( first ) - 1 ; int j = strlen ( second ) - 1 ; if ( i < 0 || j < 0 ) return ; int pre = 0 ; int total = 0 ; while ( i >= 0 && j >= 0 ) { total = first [ i -- ] - '0' + second [ j -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } while ( i >= 0 ) { total = first [ i -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } while ( j >= 0 ) { total = second [ j -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } if ( pre > 0 ) result [ 0 ] = pre + '0' ; else memmove ( result , result + 1 , MAXLEN ); } int main () { int times = 0 , i = 1 ; cin >> times ; while ( i <= times ) { memset ( first , '\\0' , sizeof ( first )); memset ( second , '\\0' , sizeof ( second )); memset ( result , '\\0' , sizeof ( result )); cin >> first >> second ; strPlus (); cout << \"Case \" << i ++ << \":\" << endl ; cout << first << \" + \" << second << \" = \" << result << endl ; } return 0 ; } 带小数的大数加法 输入包含两个正数A,B（可能为小数且位数不大于400） 输出A+B的结果，结果需要是最简的形式 需要考虑以下几点： 1. 带小数的加法，需要按小数点位置对齐 2. 输出结果小数点后面0结尾或小数点的部分应被舍去 #include \"iostream\" #include \"string.h\" using namespace std ; #define max 1000 char fst [ max ], sec [ max ], result [ max * 2 ]; void bigFloatPlus () { int len_fst = strlen ( fst ); int len_sec = strlen ( sec ); int dotPos1 = 0 , dotPos2 = 0 ; while ( dotPos1 < len_fst ) { if ( '.' == fst [ dotPos1 ]) break ; dotPos1 ++ ; } while ( dotPos2 < len_sec ) { if ( '.' == sec [ dotPos2 ]) break ; dotPos2 ++ ; } //如果输入为整数, 在后面添加小数点便于循环 if ( dotPos1 == len_fst ) { fst [ dotPos1 ] = '.' ; fst [ dotPos1 + 1 ] = '0' ; fst [ dotPos1 + 2 ] = '\\0' ; len_fst += 2 ; } if ( dotPos2 == len_sec ) { sec [ dotPos2 ] = '.' ; sec [ dotPos2 + 1 ] = '0' ; sec [ dotPos2 + 2 ] = '\\0' ; len_sec += 2 ; } //将小数点后面位数较多的部分直接复制 int len1 = len_fst - 1 - dotPos1 ; int len2 = len_sec - 1 - dotPos2 ; int i = len_fst - 1 , j = len_sec - 1 ; int index = sizeof ( result ) - 2 ; if ( len1 > len2 ) { memcpy ( result + index - ( len1 - len2 - 1 ), fst + i - ( len1 - len2 - 1 ), len1 - len2 ); i -= len1 - len2 ; index -= len1 - len2 ; } if ( len1 < len2 ) { memcpy ( result + index - ( len2 - len1 - 1 ), sec + j - ( len2 - len1 - 1 ), len2 - len1 ); j -= len2 - len1 ; index -= len2 - len1 ; } int pre = 0 , tmp = 0 ; while ( i >= 0 && j >= 0 ) { if ( '.' == fst [ i ]) { result [ index -- ] = '.' ; i -- ; j -- ; continue ; } tmp = pre + fst [ i -- ] - '0' + sec [ j -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } while ( i >= 0 ) { if ( '.' == fst [ i ]) { result [ index -- ] = '.' ; i -- ; continue ; } tmp = pre + fst [ i -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } while ( j >= 0 ) { if ( '.' == sec [ j ]) { result [ index -- ] = '.' ; j -- ; continue ; } tmp = pre + sec [ j -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } if ( pre > 0 ) result [ index -- ] = pre + '0' ; int tail = sizeof ( result ) - 2 ; while ( tail > index ) { if ( result [ tail ] != '0' && result [ tail ] != '.' ) break ; else tail -- ; } result [ tail + 1 ] = '\\0' ; memmove ( result , result + index + 1 , tail - index ); } int main () { memset ( fst , '\\0' , sizeof ( fst )); memset ( sec , '\\0' , sizeof ( sec )); while ( cin >> fst >> sec ) { memset ( result , '\\0' , sizeof ( result )); bigFloatPlus (); cout << result << endl ; } return 0 ; }","tags":"算法","loc":"http://klouse2014.github.io/interview_bignum","title":"大数问题"},{"text":"发现很多shell命令看完之后不用渐渐就忘了, 因此把常用的命令总结一下后面有遇到的再更新。 常用命令 find find [path] [options] [tests] [actions] path为绝对路径或相对路径 option选项 -maxdepths N 最多搜索N层目录 tests提供多种测试, 按顺序应用到搜索上, false跳过, true对当前文件采取actions -name pattern 文件名模式匹配 -newer file1 ! file2 比指定file1新, file2旧的文件 -type d/f 为目录/文件 -mtime +n/-n 按照文件更改时间来查找文件, -n表示更改时间距现在n天以内, +n表示更改时间在n天以前 -mmin n 最后n分钟更改的文件 -empty 文件为空 -a/-and 两个测试必须为真, -o/-or 其中一个为真, !/-not 取反 可通过括号增加测试优先级, 前面需加\\ actions为执行语句 -exec -ok 必须以\\;结尾。ok会在执行前询问,使用{}传入后会被当前文件的完整路径取代 -print 打印文件名 grep grep [options] PATTERN [files] 用于在文件中搜索字符串 options选项 -c 输出匹配行的数目，而不是输出匹配的行 -E 启动拓展表达式 -i 忽略大小写 -l 只列出包含匹配行的文件名，而不输出真正的匹配行 -v 对匹配模式取反，即搜索不匹配行而不是匹配行 -n 打印包含匹配项的行和行标 test test expression or [ expression ] 字符串 =/!= 是否相等 -n/-z 是否为空 算术比较 -eq -ne -gt -ge -lt -le ! 文件 -e 存在 -f 存在并且是文件 -d 存在并且是目录 –w/v/x 可读/写/执行 cut -f 按字段 -c 按字符 -b 按字节 -d 设置分割符 N-M, N设置输出范围 mkdir -p 或 —parents 表示若所要创建的目录的上层目录没有创建，则会一并创建上层目录 -m 指定目录的权限 mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a} tree project/ project/ |-- bin |-- demo | `-- stat | `-- a |-- doc | |-- html | |-- info | `-- pdf |-- lib | `-- ext `-- src comm 比较两个已排序的文件。在缺省情况下将三栏输出写到标准输出。这些栏由以下内容组成：只在 File1 中的行、只在 File2 中的行、既在 File1，又在 File2 中的行 comm [-123] [File1] [File2] -1 不显示只在第1个文件里出现过的列 -2 不显示只在第2个文件里出现过的列 -3 不显示只在第1和第2个文件里出现过的列 expr 或 $((…)) 将它的参数作为一个表达式来求值 x = `expr $x + 1` `…` 或 $(…) 执行中间的语句, 结果就是命令的输出，而不是该命令的退出状态。将它的字符串形式的输出结果 ${…} 为保护变量名中类似$i部分的扩展，需将其放入花括号中 ${param:-default} 当param为空时将它设置为default ${#param} 给出param的长度 ${param%word} 从param尾部开始删除与word匹配的最小部分，返回剩余部分 ${param%%word} 从param尾部开始删除与word匹配的最长部分，返回剩余部分 ${param#word} 从param头部开始删除与word匹配的最小部分，返回剩余部分 ${param##word} 从param头部开始删除与word匹配的最长部分，返回剩余部分 for或while 双括号形式，注意与算术计算$((…))区分 for((i=1;i<100;i++;));do ... done while((i<100));do ... done for in 形式 for file in `ls *` while 中括号形式 while [ $ i -le $ max ];do ... done Here Document Here Document 是在Linux Shell 中的一种特殊的重定向方式，它的基本的形式如下 cmd << delimiter Here Document Content delimiter 这里要注意, delimiter 只是一个标识而已，可以替换成任意的合法字符 在Here Document 的内容中，不仅可以包括普通的字符，还可以在里面使用变量，例如 cat << EOF > output.sh echo \"This is output\" echo $1 EOF 使用sh here.sh HereDocument 运行脚本得到output.sh的内容 echo \"This is output\" echo HereDocument 在这里 $1 被展开成为了脚本的参数 HereDocument 还有一个用法就是将 << 变为 <<- , 这样唯一变化就是Here Document 的内容部分每行前面的 tab (制表符)将会被删除掉，方便阅读代码 tar 可以归档多个文件和目录到一个.tar文件下，还可以从一个归档文件中抽取一个文件和目录。 tar [-c][-r][-t][-x][-v][-z][f 文件名] 文件和目录名 -c 创建归档文件 -r 增加文件到归档文件中 -t 查看归档文件中的文件 -x 解开归档文件 -v 显示冗长信息 -z 用gzip对存档压缩或解压 tar –czvf back.tar.gz 文件1 目录1 文件2 tar –xzvf back.tar.gz sort 对文件进行排序。 sort [OPTION]... [FILE]... -u 在输出中去除重复的行 -r sort默认是升序排列, -r为降序排列 -o 重定向到文件, 可以使用原文件 -n 以数值进行排序 -t -k -t用于设置分隔符, -k用来指定排序的列数 $ sort -n -t ' ' -k 3r -k 2 facebook.txt baidu 100 5000 google 110 5000 sohu 100 4500 guge 50 3000 uniq 检查重复的行 uniq [-c | -d | -u] [-i] [-f num] [-s chars] [input_file [output_file]] -c, —count 在每行前显示该行重复次数 -d, —repeated 只输出重复的行 -D, —all-repeated 只输出重复的行，不过有几行输出几行 -f, —skip-fields=N -f 忽略的段数，-f 1 忽略第一段 -i, —ignore-case 不区分大小写 -s, —skip-chars=N 根-f有点像，不过-s是忽略，后面多少个字符 -s 5就忽略后面5个字符 -u, —unique 去除重复的后，全部显示出来，根mysql的distinct功能上有点像","tags":"Linux","loc":"http://klouse2014.github.io/shell+command","title":"shell命令备忘"},{"text":"开始吧 github准备 创建username.github.io 数据仓库 pelican准备 新建blog文件件, 执行pelican-quickstart命令创建基本框架 将output文件夹绑定到数据仓库 cd output git init git remote add origin https://github.com/username/username.github.io.git git pull origin master pelican 包含很多主题和插件，可以直接clone使用 pelican-themes pelican-plugins 本例使用 elegant 主题 elegant主题说明文档 生成网页文件以及在本机上测试 make html make serve 注意事项 增加评论功能 Pelican 使用Disqus评论, 可以申请在Disqus上申请一个站点, 然后在pelicanconf.py里添加或修改DISQUS_SITENAME项: DISQUS_SITENAME = u\"xxxxx\" 参考资料 pelican官方说明文档 配置文件参考","tags":"Pelican","loc":"http://klouse2014.github.io/GitHub+Pelican","title":"使用GitHub＋Pelican搭建个人博客"}]}