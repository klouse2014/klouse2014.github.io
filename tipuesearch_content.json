{"pages":[{"text":"前言 上了一年的班，之前看的面试算法基本忘的一干二净了。在这回顾一下，争取能恢复到之前的水平。后面再学习的深入一些，以后说不定用的上呢。 算术类 把一个字符串转化为整数。 需要考虑以下几点： 字符串开头：正负号需记下来, 开头连续为0的位应该跳过; 负号后紧跟0报错 字符串中异常字符：非0～9数字应该报错 当转化数字超出int边界时，应该报错 #include \"iostream\" using namespace std ; #define MAX 0x7fffffff #define MIN 0x80000000 //字符合法性检查 bool charIsOk ( char c ) { if ( c > '9' || c < '0' ) return false ; else return true ; } //将输入字符串转化为整数输出 int StrToInt ( char * str , char * errMsg ) { if ( str == NULL ) { strcpy ( errMsg , \"传入指针为空\" ); return - 1 ; } //字符串开头检查 int sign = 1 ; int result = 0 , i = 0 ; if ( str [ 0 ] == '-' ) { sign = - 1 ; if ( str [ 1 ] == '0' ) { strcpy ( errMsg , \"负号后不能跟0\" ); return - 1 ; } i ++ ; } if ( str [ 0 ] == '+' ) i ++ ; if ( str [ 0 ] != '+' && str [ 0 ] != '-' && ! charIsOk ( str [ 0 ])) { strcpy ( errMsg , \"字符串开头异常\" ); return - 1 ; } bool isStart = false ; for (; i < strlen ( str ); i ++ ) { if ( str [ i ] == '0' && ! isStart ) continue ; if ( ! charIsOk ( str [ i ])) { //合法性检查 strcpy ( errMsg , \"字符串内容异常\" ); return - 1 ; } if ( str [ i ] != '0' || isStart ) { isStart = true ; //需检查是否溢出 if ( 1 == sign && ( int ( MAX ) - ( str [ i ] - '0' )) / 10 < result ) { strcpy ( errMsg , \"字符表示数字溢出\" ); return - 1 ; } if ( - 1 == sign && ( int ( MIN ) + ( str [ i ] - '0' )) / 10 > result * sign ) { strcpy ( errMsg , \"字符串表示数据溢出\" ); return - 1 ; } result = result * 10 + str [ i ] - '0' ; } } if ( result != 0 && sign == - 1 ) result *= sign ; return result ; } int main () { cout << int ( MAX ) << \" \" << int ( MIN ) << endl ; char str [ 100 ] = { 0 }, err [ 30 ] = { 0 }; cin >> str ; int output = StrToInt ( str , err ); if ( strlen ( err ) != 0 ) cout << err << endl ; else cout << output << endl ; return 0 ; }","tags":"算法","loc":"http://klouse2014.github.io/interview","title":"面试题总结"},{"text":"发现很多shell命令看完之后不用渐渐就忘了, 因此把常用的命令总结一下后面有遇到的再更新。 常用命令 find find [path] [options] [tests] [actions] path为绝对路径或相对路径 option选项 -maxdepths N 最多搜索N层目录 tests提供多种测试, 按顺序应用到搜索上, false跳过, true对当前文件采取actions -name pattern 文件名模式匹配 -newer file1 ! file2 比指定file1新, file2旧的文件 -type d/f 为目录/文件 -mtime +n/-n 按照文件更改时间来查找文件, -n表示更改时间距现在n天以内, +n表示更改时间在n天以前 -mmin n 最后n分钟更改的文件 -empty 文件为空 -a/-and 两个测试必须为真, -o/-or 其中一个为真, !/-not 取反 可通过括号增加测试优先级, 前面需加\\ actions为执行语句 -exec -ok 必须以\\;结尾。ok会在执行前询问,使用{}传入后会被当前文件的完整路径取代 -print 打印文件名 grep grep [options] PATTERN [files] 用于在文件中搜索字符串 options选项 -c 输出匹配行的数目，而不是输出匹配的行 -E 启动拓展表达式 -i 忽略大小写 -l 只列出包含匹配行的文件名，而不输出真正的匹配行 -v 对匹配模式取反，即搜索不匹配行而不是匹配行 -n 打印包含匹配项的行和行标 test test expression or [ expression ] 字符串 =/!= 是否相等 -n/-z 是否为空 算术比较 -eq -ne -gt -ge -lt -le ! 文件 -e 存在 -f 存在并且是文件 -d 存在并且是目录 –w/v/x 可读/写/执行 cut -f 按字段 -c 按字符 -b 按字节 -d 设置分割符 N-M, N设置输出范围 mkdir -p 或 —parents 表示若所要创建的目录的上层目录没有创建，则会一并创建上层目录 -m 指定目录的权限 mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a} tree project/ project/ |-- bin |-- demo | `-- stat | `-- a |-- doc | |-- html | |-- info | `-- pdf |-- lib | `-- ext `-- src comm 比较两个已排序的文件。在缺省情况下将三栏输出写到标准输出。这些栏由以下内容组成：只在 File1 中的行、只在 File2 中的行、既在 File1，又在 File2 中的行 comm [-123] [File1] [File2] -1 不显示只在第1个文件里出现过的列 -2 不显示只在第2个文件里出现过的列 -3 不显示只在第1和第2个文件里出现过的列 expr 或 $((…)) 将它的参数作为一个表达式来求值 x = `expr $x + 1` `…` 或 $(…) 执行中间的语句, 结果就是命令的输出，而不是该命令的退出状态。将它的字符串形式的输出结果 ${…} 为保护变量名中类似$i部分的扩展，需将其放入花括号中 ${param:-default} 当param为空时将它设置为default ${#param} 给出param的长度 ${param%word} 从param尾部开始删除与word匹配的最小部分，返回剩余部分 ${param%%word} 从param尾部开始删除与word匹配的最长部分，返回剩余部分 ${param#word} 从param头部开始删除与word匹配的最小部分，返回剩余部分 ${param##word} 从param头部开始删除与word匹配的最长部分，返回剩余部分 for或while 双括号形式，注意与算术计算$((…))区分 for((i=1;i<100;i++;));do ... done while((i<100));do ... done for in 形式 for file in `ls *` while 中括号形式 while [ $ i -le $ max ];do ... done Here Document Here Document 是在Linux Shell 中的一种特殊的重定向方式，它的基本的形式如下 cmd << delimiter Here Document Content delimiter 这里要注意, delimiter 只是一个标识而已，可以替换成任意的合法字符 在Here Document 的内容中，不仅可以包括普通的字符，还可以在里面使用变量，例如 cat << EOF > output.sh echo \"This is output\" echo $1 EOF 使用sh here.sh HereDocument 运行脚本得到output.sh的内容 echo \"This is output\" echo HereDocument 在这里 $1 被展开成为了脚本的参数 HereDocument 还有一个用法就是将 << 变为 <<- , 这样唯一变化就是Here Document 的内容部分每行前面的 tab (制表符)将会被删除掉，方便阅读代码 tar 可以归档多个文件和目录到一个.tar文件下，还可以从一个归档文件中抽取一个文件和目录。 tar [-c][-r][-t][-x][-v][-z][f 文件名] 文件和目录名 -c 创建归档文件 -r 增加文件到归档文件中 -t 查看归档文件中的文件 -x 解开归档文件 -v 显示冗长信息 -z 用gzip对存档压缩或解压 tar –czvf back.tar.gz 文件1 目录1 文件2 tar –xzvf back.tar.gz","tags":"Linux","loc":"http://klouse2014.github.io/shell+command","title":"shell命令备忘"},{"text":"开始吧 github准备 创建username.github.io 数据仓库 pelican准备 新建blog文件件, 执行pelican-quickstart命令创建基本框架 将output文件夹绑定到数据仓库 cd output git init git remote add origin https://github.com/username/username.github.io.git git pull origin master pelican 包含很多主题和插件，可以直接clone使用 pelican-themes pelican-plugins 本例使用 elegant 主题 elegant主题说明文档 生成网页文件以及在本机上测试 make html make serve 注意事项 增加评论功能 Pelican 使用Disqus评论, 可以申请在Disqus上申请一个站点, 然后在pelicanconf.py里添加或修改DISQUS_SITENAME项: DISQUS_SITENAME = u\"xxxxx\" 参考资料 pelican官方说明文档 配置文件参考","tags":"Pelican","loc":"http://klouse2014.github.io/GitHub+Pelican","title":"使用GitHub＋Pelican搭建个人博客"}]}