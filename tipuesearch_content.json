{"pages":[{"text":"把一个字符串转化为整数。 需要考虑以下几点： 字符串开头：正负号需记下来, 开头连续为0的位应该跳过; 负号后紧跟0报错 字符串中异常字符：非0～9数字应该报错 当转化数字超出int边界时，应该报错 #include \"iostream\" using namespace std ; #define MAX 0x7fffffff #define MIN 0x80000000 //字符合法性检查 bool charIsOk ( char c ) { if ( c > '9' || c < '0' ) return false ; else return true ; } //将输入字符串转化为整数输出 int StrToInt ( char * str , char * errMsg ) { if ( str == NULL ) { strcpy ( errMsg , \"传入指针为空\" ); return - 1 ; } //字符串开头检查 int sign = 1 ; int result = 0 , i = 0 ; if ( str [ 0 ] == '-' ) { sign = - 1 ; if ( str [ 1 ] == '0' ) { strcpy ( errMsg , \"负号后不能跟0\" ); return - 1 ; } i ++ ; } if ( str [ 0 ] == '+' ) i ++ ; if ( str [ 0 ] != '+' && str [ 0 ] != '-' && ! charIsOk ( str [ 0 ])) { strcpy ( errMsg , \"字符串开头异常\" ); return - 1 ; } bool isStart = false ; for (; i < strlen ( str ); i ++ ) { if ( str [ i ] == '0' && ! isStart ) continue ; if ( ! charIsOk ( str [ i ])) { //合法性检查 strcpy ( errMsg , \"字符串内容异常\" ); return - 1 ; } if ( str [ i ] != '0' || isStart ) { isStart = true ; //需检查是否溢出 if ( 1 == sign && ( int ( MAX ) - ( str [ i ] - '0' )) / 10 < result ) { strcpy ( errMsg , \"字符表示数字溢出\" ); return - 1 ; } if ( - 1 == sign && ( int ( MIN ) + ( str [ i ] - '0' )) / 10 > result * sign ) { strcpy ( errMsg , \"字符串表示数据溢出\" ); return - 1 ; } result = result * 10 + str [ i ] - '0' ; } } if ( result != 0 && sign == - 1 ) result *= sign ; return result ; } int main () { cout << int ( MAX ) << \" \" << int ( MIN ) << endl ; char str [ 100 ] = { 0 }, err [ 30 ] = { 0 }; cin >> str ; int output = StrToInt ( str , err ); if ( strlen ( err ) != 0 ) cout << err << endl ; else cout << output << endl ; return 0 ; } 大数加法 I have a very simple problem for you. Given two integers A and B, your job is to calculate the Sum of A + B. A,B must be positive. #include \"iostream\" #include \"string.h\" using namespace std ; #define MAXLEN 1001 char first [ MAXLEN ], second [ MAXLEN ], result [ MAXLEN + 1 ]; void strPlus () { int index = max ( strlen ( first ), strlen ( second )); int i = strlen ( first ) - 1 ; int j = strlen ( second ) - 1 ; if ( i < 0 || j < 0 ) return ; int pre = 0 ; int total = 0 ; while ( i >= 0 && j >= 0 ) { total = first [ i -- ] - '0' + second [ j -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } while ( i >= 0 ) { total = first [ i -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } while ( j >= 0 ) { total = second [ j -- ] - '0' + pre ; pre = total / 10 ; result [ index -- ] = total % 10 + '0' ; } if ( pre > 0 ) result [ 0 ] = pre + '0' ; else memmove ( result , result + 1 , MAXLEN ); } int main () { int times = 0 , i = 1 ; cin >> times ; while ( i <= times ) { memset ( first , '\\0' , sizeof ( first )); memset ( second , '\\0' , sizeof ( second )); memset ( result , '\\0' , sizeof ( result )); cin >> first >> second ; strPlus (); cout << \"Case \" << i ++ << \":\" << endl ; cout << first << \" + \" << second << \" = \" << result << endl ; } return 0 ; } 带小数的大数加法 输入包含两个正数A,B（可能为小数且位数不大于400） 输出A+B的结果，结果需要是最简的形式 需要考虑以下几点： 带小数的加法，需要按小数点位置对齐 输出结果小数点后面0结尾或小数点的部分应被舍去 #include \"iostream\" #include \"string.h\" using namespace std ; #define max 1000 char fst [ max ], sec [ max ], result [ max * 2 ]; void bigFloatPlus () { int len_fst = strlen ( fst ); int len_sec = strlen ( sec ); int dotPos1 = 0 , dotPos2 = 0 ; while ( dotPos1 < len_fst ) { if ( '.' == fst [ dotPos1 ]) break ; dotPos1 ++ ; } while ( dotPos2 < len_sec ) { if ( '.' == sec [ dotPos2 ]) break ; dotPos2 ++ ; } //如果输入为整数, 在后面添加小数点便于循环 if ( dotPos1 == len_fst ) { fst [ dotPos1 ] = '.' ; fst [ dotPos1 + 1 ] = '0' ; fst [ dotPos1 + 2 ] = '\\0' ; len_fst += 2 ; } if ( dotPos2 == len_sec ) { sec [ dotPos2 ] = '.' ; sec [ dotPos2 + 1 ] = '0' ; sec [ dotPos2 + 2 ] = '\\0' ; len_sec += 2 ; } //将小数点后面位数较多的部分直接复制 int len1 = len_fst - 1 - dotPos1 ; int len2 = len_sec - 1 - dotPos2 ; int i = len_fst - 1 , j = len_sec - 1 ; int index = sizeof ( result ) - 2 ; if ( len1 > len2 ) { memcpy ( result + index - ( len1 - len2 - 1 ), fst + i - ( len1 - len2 - 1 ), len1 - len2 ); i -= len1 - len2 ; index -= len1 - len2 ; } if ( len1 < len2 ) { memcpy ( result + index - ( len2 - len1 - 1 ), sec + j - ( len2 - len1 - 1 ), len2 - len1 ); j -= len2 - len1 ; index -= len2 - len1 ; } int pre = 0 , tmp = 0 ; while ( i >= 0 && j >= 0 ) { if ( '.' == fst [ i ]) { result [ index -- ] = '.' ; i -- ; j -- ; continue ; } tmp = pre + fst [ i -- ] - '0' + sec [ j -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } while ( i >= 0 ) { if ( '.' == fst [ i ]) { result [ index -- ] = '.' ; i -- ; continue ; } tmp = pre + fst [ i -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } while ( j >= 0 ) { if ( '.' == sec [ j ]) { result [ index -- ] = '.' ; j -- ; continue ; } tmp = pre + sec [ j -- ] - '0' ; pre = tmp / 10 ; result [ index -- ] = tmp % 10 + '0' ; } if ( pre > 0 ) result [ index -- ] = pre + '0' ; int tail = sizeof ( result ) - 2 ; while ( tail > index ) { if ( result [ tail ] != '0' && result [ tail ] != '.' ) break ; else tail -- ; } result [ tail + 1 ] = '\\0' ; memmove ( result , result + index + 1 , tail - index ); } int main () { memset ( fst , '\\0' , sizeof ( fst )); memset ( sec , '\\0' , sizeof ( sec )); while ( cin >> fst >> sec ) { memset ( result , '\\0' , sizeof ( result )); bigFloatPlus (); cout << result << endl ; } return 0 ; }","tags":"算法","loc":"http://klouse2014.github.io/interview_bignum","title":"大数问题"},{"text":"发现很多shell命令看完之后不用渐渐就忘了, 因此把常用的命令总结一下后面有遇到的再更新。 常用命令 find find [path] [options] [tests] [actions] path为绝对路径或相对路径 option选项 -maxdepths N 最多搜索N层目录 tests提供多种测试, 按顺序应用到搜索上, false跳过, true对当前文件采取actions -name pattern 文件名模式匹配 -newer file1 ! file2 比指定file1新, file2旧的文件 -type d/f 为目录/文件 -mtime +n/-n 按照文件更改时间来查找文件, -n表示更改时间距现在n天以内, +n表示更改时间在n天以前 -mmin n 最后n分钟更改的文件 -empty 文件为空 -a/-and 两个测试必须为真, -o/-or 其中一个为真, !/-not 取反 可通过括号增加测试优先级, 前面需加\\ actions为执行语句 -exec -ok 必须以\\;结尾。ok会在执行前询问,使用{}传入后会被当前文件的完整路径取代 -print 打印文件名 grep grep [options] PATTERN [files] 用于在文件中搜索字符串 options选项 -c 输出匹配行的数目，而不是输出匹配的行 -E 启动拓展表达式 -i 忽略大小写 -l 只列出包含匹配行的文件名，而不输出真正的匹配行 -v 对匹配模式取反，即搜索不匹配行而不是匹配行 -n 打印包含匹配项的行和行标 test test expression or [ expression ] 字符串 =/!= 是否相等 -n/-z 是否为空 算术比较 -eq -ne -gt -ge -lt -le ! 文件 -e 存在 -f 存在并且是文件 -d 存在并且是目录 –w/v/x 可读/写/执行 cut -f 按字段 -c 按字符 -b 按字节 -d 设置分割符 N-M, N设置输出范围 mkdir -p 或 —parents 表示若所要创建的目录的上层目录没有创建，则会一并创建上层目录 -m 指定目录的权限 mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a} tree project/ project/ |-- bin |-- demo | `-- stat | `-- a |-- doc | |-- html | |-- info | `-- pdf |-- lib | `-- ext `-- src comm 比较两个已排序的文件。在缺省情况下将三栏输出写到标准输出。这些栏由以下内容组成：只在 File1 中的行、只在 File2 中的行、既在 File1，又在 File2 中的行 comm [-123] [File1] [File2] -1 不显示只在第1个文件里出现过的列 -2 不显示只在第2个文件里出现过的列 -3 不显示只在第1和第2个文件里出现过的列 expr 或 $((…)) 将它的参数作为一个表达式来求值 x = `expr $x + 1` `…` 或 $(…) 执行中间的语句, 结果就是命令的输出，而不是该命令的退出状态。将它的字符串形式的输出结果 ${…} 为保护变量名中类似$i部分的扩展，需将其放入花括号中 ${param:-default} 当param为空时将它设置为default ${#param} 给出param的长度 ${param%word} 从param尾部开始删除与word匹配的最小部分，返回剩余部分 ${param%%word} 从param尾部开始删除与word匹配的最长部分，返回剩余部分 ${param#word} 从param头部开始删除与word匹配的最小部分，返回剩余部分 ${param##word} 从param头部开始删除与word匹配的最长部分，返回剩余部分 for或while 双括号形式，注意与算术计算$((…))区分 for((i=1;i<100;i++;));do ... done while((i<100));do ... done for in 形式 for file in `ls *` while 中括号形式 while [ $ i -le $ max ];do ... done Here Document Here Document 是在Linux Shell 中的一种特殊的重定向方式，它的基本的形式如下 cmd << delimiter Here Document Content delimiter 这里要注意, delimiter 只是一个标识而已，可以替换成任意的合法字符 在Here Document 的内容中，不仅可以包括普通的字符，还可以在里面使用变量，例如 cat << EOF > output.sh echo \"This is output\" echo $1 EOF 使用sh here.sh HereDocument 运行脚本得到output.sh的内容 echo \"This is output\" echo HereDocument 在这里 $1 被展开成为了脚本的参数 HereDocument 还有一个用法就是将 << 变为 <<- , 这样唯一变化就是Here Document 的内容部分每行前面的 tab (制表符)将会被删除掉，方便阅读代码 tar 可以归档多个文件和目录到一个.tar文件下，还可以从一个归档文件中抽取一个文件和目录。 tar [-c][-r][-t][-x][-v][-z][f 文件名] 文件和目录名 -c 创建归档文件 -r 增加文件到归档文件中 -t 查看归档文件中的文件 -x 解开归档文件 -v 显示冗长信息 -z 用gzip对存档压缩或解压 tar –czvf back.tar.gz 文件1 目录1 文件2 tar –xzvf back.tar.gz","tags":"Linux","loc":"http://klouse2014.github.io/shell+command","title":"shell命令备忘"},{"text":"开始吧 github准备 创建username.github.io 数据仓库 pelican准备 新建blog文件件, 执行pelican-quickstart命令创建基本框架 将output文件夹绑定到数据仓库 cd output git init git remote add origin https://github.com/username/username.github.io.git git pull origin master pelican 包含很多主题和插件，可以直接clone使用 pelican-themes pelican-plugins 本例使用 elegant 主题 elegant主题说明文档 生成网页文件以及在本机上测试 make html make serve 注意事项 增加评论功能 Pelican 使用Disqus评论, 可以申请在Disqus上申请一个站点, 然后在pelicanconf.py里添加或修改DISQUS_SITENAME项: DISQUS_SITENAME = u\"xxxxx\" 参考资料 pelican官方说明文档 配置文件参考","tags":"Pelican","loc":"http://klouse2014.github.io/GitHub+Pelican","title":"使用GitHub＋Pelican搭建个人博客"}]}